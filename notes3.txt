// FILE: DPQueue.h
// CLASS PROVIDED: p_queue (priority queue ADT)
//
// TYPEDEFS and MEMBER CONSTANTS for the p_queue class:
//   typedef _____ value_type
//     p_queue::value_type is the data type of the items in
//     the p_queue. It may be any of the C++ built-in types
//     (int, char, etc.), or a class with a default constructor, a
//     copy constructor, an assignment operator, and a less-than
//     operator forming a strict weak ordering.
//
//   typedef _____ size_type
//     p_queue::size_type is the data type considered best-suited
//     for any variable meant for counting and sizing (as well as
//     array-indexing) purposes; e.g.: it is the data type for a
//     variable representing how many items are in the p_queue.
//     It is also the data type of the priority associated with
//     each item in the p_queue
//
//   static const size_type DEFAULT_CAPACITY = _____
//    p_queue::DEFAULT_CAPACITY is the default initial capacity of a
//    p_queue that is created by the default constructor.
//
// CONSTRUCTOR for the p_queue class:
//   p_queue(size_type initial_capacity = DEFAULT_CAPACITY)
//     Pre:  initial_capacity > 0
//     Post: The p_queue has been initialized to an empty p_queue.
//       The push function will work efficiently (without allocating
//       new memory) until this capacity is reached.
//     Note: If Pre is not met, initial_capacity will be adjusted to
//       DEFAULT_CAPACITY. I.e., when creating a p_queue object,
//       client can override initial_capacity with something deemed
//       more appropriate than DEFAULT_CAPACITY; but if (in doing so)
//       client mis-specifies 0 (NOTE: size_type is unsigned, thus
//       can't be negative) as the overriding size, DEFAULT_CAPACITY
//       remains as the value to be used for initial_capacity (this
//       is to ensure no attempt is made at allocating memory that's
//       0 in amount).
//
// MODIFICATION MEMBER FUNCTIONS for the p_queue class:
//   void push(const value_type& entry, size_type priority)
//     Pre:  (none)
//     Post: A new copy of item with the specified data and priority
//           has been added to the p_queue.
//
//   void pop()
//     Pre:  size() > 0.
//     Post: The highest priority item has been removed from the
//           p_queue. (If several items have the equal priority,
//           then the implementation may decide which one to remove.)
//
// CONSTANT MEMBER FUNCTIONS for the p_queue class:
//   size_type size() const
//     Pre:  (none)
//     Post: The return value is the total number of items in the
//           p_queue.
//
//   value_type front() const
//     Pre:  size() > 0.
//     Post: The return value is the data of the highest priority
//           item in the p_queue, but the p_queue is unchanged.
//           (If several items have equal priority, then the
//           implementation may decide which one to return.)
//
//   bool empty() const
//     Pre:  (none)
//     Post: The return value is true if the p_queue is empty,
//           otherwise false.
//
// VALUE SEMANTICS for the p_queue class:
//   Assignments and the copy constructor may be used with p_queue
//   objects.

#ifndef D_P_QUEUE_H
#define D_P_QUEUE_H

#include <cstdlib> // provides size_t

namespace CS3358_SP2024_A7
{
   class p_queue
   {
   public:
      // TYPEDEFS and MEMBER CONSTANTS
      typedef int value_type;
      typedef size_t size_type;
      static const size_type DEFAULT_CAPACITY = 1;
      // CONSTRUCTORS AND DESTRUCTOR
      p_queue(size_type initial_capacity = DEFAULT_CAPACITY);
      p_queue(const p_queue& src);
      ~p_queue();
      // MODIFICATION MEMBER FUNCTIONS
      p_queue& operator=(const p_queue& rhs);
      void push(const value_type& entry, size_type priority);
      void pop();
      // CONSTANT MEMBER FUNCTIONS
      size_type size() const;
      bool empty() const;
      value_type front() const;
      // EXTRA CONSTANT MEMBER FUNCTION FOR DEBUG PRINTING
      void print_tree(const char message[] = "", size_type i = 0) const;
      void print_array(const char message[] = "") const;

   private:
      // STRUCT to store information about one item in the p_queue
      struct ItemType
      {
         value_type data;
         size_type priority;
      };
      // PRIVATE MEMBER VARIABLES
      ItemType *heap;
      size_type capacity;
      size_type used;
      // HELPER FUNCTIONS
      void resize(size_type new_capacity);
      bool is_leaf(size_type i) const;
      size_type parent_index(size_type i) const;
      size_type parent_priority(size_type i) const;
      size_type big_child_index(size_type i) const;
      size_type big_child_priority(size_type i) const;
      void swap_with_parent(size_type i);
   };
}

#endif



// FILE: DPQueue.cpp
// IMPLEMENTS: p_queue (see DPQueue.h for documentation.)
//
// INVARIANT for the p_queue class:
//   1. The number of items in the p_queue is stored in the member
//      variable used.
//   2. The items themselves are stored in a dynamic array (partially
//      filled in general) organized to follow the usual heap storage
//      rules.
//      2.1 The member variable heap stores the starting address
//          of the array (i.e., heap is the array's name). Thus,
//          the items in the p_queue are stored in the elements
//          heap[0] through heap[used - 1].
//      2.2 The member variable capacity stores the current size of
//          the dynamic array (i.e., capacity is the maximum number
//          of items the array currently can accommodate).
//          NOTE: The size of the dynamic array (thus capacity) can
//                be resized up or down where needed or appropriate
//                by calling resize(...).
// NOTE: Private helper functions are implemented at the bottom of
// this file along with their precondition/postcondition contracts.

#include <cassert>  // provides assert function
#include <iostream> // provides cin, cout
#include <iomanip>  // provides setw
#include <cmath>    // provides log2
#include "DPQueue.h"

using namespace std;

namespace CS3358_SP2024_A7
{
   // EXTRA MEMBER FUNCTIONS FOR DEBUG PRINTING
   void p_queue::print_tree(const char message[], size_type i) const
   // Pre:  (none)
   // Post: If the message is non-empty, it has first been written to
   //       cout. After that, the portion of the heap with root at
   //       node i has been written to the screen. Each node's data
   //       is indented 4*d, where d is the depth of the node.
   //       NOTE: The default argument for message is the empty string,
   //             and the default argument for i is zero. For example,
   //             to print the entire tree of a p_queue p, with a
   //             message of "The tree:", you can call:
   //                p.print_tree("The tree:");
   //             This call uses the default argument i=0, which prints
   //             the whole tree.
   {
      const char NO_MESSAGE[] = "";
      size_type depth;

      if (message[0] != '\0')
         cout << message << endl;

      if (i >= used)
         cout << "(EMPTY)" << endl;
      else
      {
         depth = size_type(log(double(i + 1)) / log(2.0) + 0.1);
         if (2 * i + 2 < used)
            print_tree(NO_MESSAGE, 2 * i + 2);
         cout << setw(depth * 3) << "";
         cout << heap[i].data;
         cout << '(' << heap[i].priority << ')' << endl;
         if (2 * i + 1 < used)
            print_tree(NO_MESSAGE, 2 * i + 1);
      }
   }

   void p_queue::print_array(const char message[]) const
   // Pre:  (none)
   // Post: If the message is non-empty, it has first been written to
   //       cout. After that, the contents of the array representing
   //       the current heap has been written to cout in one line with
   //       values separated one from another with a space.
   //       NOTE: The default argument for message is the empty string.
   {
      if (message[0] != '\0')
         cout << message << endl;

      if (used == 0)
         cout << "(EMPTY)" << endl;
      else
         for (size_type i = 0; i < used; i++)
            cout << heap[i].data << ' ';
   }

   // CONSTRUCTORS AND DESTRUCTOR

   p_queue::p_queue(size_type initial_capacity)
   {
      this->capacity = 0;
      this->used = 0;
      if (initial_capacity < 1) // making sure capacity is not zero or neg
         capacity = DEFAULT_CAPACITY;
      this->heap = new ItemType[capacity];
      //!      cerr << "p_queue() not implemented yet" << endl;
   }

   p_queue::p_queue(const p_queue &src)
   {
      heap = new ItemType[capacity];

      // copy the heap
      for (size_type i = 0; i < capacity; ++i)
         heap[i] = src.heap[i];
      //!      cerr << "p_queue(const p_queue&) not implemented yet" << endl;
   }

   p_queue::~p_queue()
   {
      //!      cerr << "~p_queue() not implemented yet" << endl;
      delete[] heap;
      heap = nullptr;
   }

   // MODIFICATION MEMBER FUNCTIONS
   p_queue &p_queue::operator=(const p_queue &rhs)
   {
      //!      cerr << "operator=(const p_queue&) not implemented yet" << endl;
      if (this != &rhs)
      { // if this==this, just return
         ItemType *temp_heap = new ItemType[rhs.capacity];

         for (size_type i = 0; i < rhs.used; ++i)
            temp_heap[i] = rhs.heap[i];

         delete[] heap;

         heap = temp_heap;
         capacity = rhs.capacity;
         used = rhs.used;
      }
      return *this;
   }

   void p_queue::push(const value_type &entry, size_type priority)
   {
      //!      cerr << "push(const value_type&, size_type) not implemented yet" << endl;
      // check capacity
      if (used == capacity)
      {
         resize(size_type(1.5 * capacity) + 1);
      }
      size_type index = used;
      heap[used].data = entry;
      heap[used].priority = priority;
      ++used;

      // swap index while parent < child
      while (index != 0 && (parent_priority(index) < heap[index].priority))
      {
         swap_with_parent(index); // swap while parent is < child
         index = parent_index(index);
      }
   }

   void p_queue::pop()
   {
      //!      cerr << "pop() not implemented yet" << endl;
      assert(size() > 0);

      if (used == 1)
      {
         --used;
         return;
      }

      heap[0].data = heap[used - 1].data;

      heap[0].priority = heap[used - 1].priority;
      --used; // why not this->--used? IDE wouldnt allow for it,
              // although not needed it helps improve readability

      size_type tempP_index = 0,
                tempC_index = 0;

      while (!is_leaf(tempP_index) && heap[tempP_index].priority <=
                                          big_child_priority(tempP_index))
      {
         tempC_index = big_child_index(tempP_index);
         swap_with_parent(big_child_index(tempP_index));
         tempP_index = tempC_index;
      }
   }

   // CONSTANT MEMBER FUNCTIONS

   p_queue::size_type p_queue::size() const
   {
      //!      cerr << "size() not implemented yet" << endl;
      //!      return 0; // dummy return value
      return this->used;
   }

   bool p_queue::empty() const
   {
      //!      cerr << "empty() not implemented yet" << endl;
      //!      return false; // dummy return value
      return this->used == 0;
   }

   p_queue::value_type p_queue::front() const
   {
      //!      cerr << "front() not implemented yet" << endl;
      //!      return value_type(); // dummy return value
      assert(this->size() > 0);
      return heap[0].data;
   }

   // PRIVATE HELPER FUNCTIONS
   void p_queue::resize(size_type new_capacity)
   // Pre:  (none)
   // Post: The size of the dynamic array pointed to by heap (thus
   //       the capacity of the p_queue) has been resized up or down
   //       to new_capacity, but never less than used (to prevent
   //       loss of existing data).
   //       NOTE: All existing items in the p_queue are preserved and
   //             used remains unchanged.
   {
      //!      cerr << "resize(size_type) not implemented yet" << endl;
      if (new_capacity < used)
         new_capacity = used;

      ItemType *temp_heap = new ItemType[new_capacity];

      for (size_type i = 0; i < used; ++i)
         temp_heap[i] = heap[i];

      delete[] heap;
      heap = temp_heap;
      capacity = new_capacity;
   }

   bool p_queue::is_leaf(size_type i) const
   // Pre:  (i < used)
   // Post: If the item at heap[i] has no children, true has been
   //       returned, otherwise false has been returned.
   {
      //!      cerr << "is_leaf(size_type) not implemented yet" << endl;
      //!      return false; // dummy return value
      assert(!(is_leaf(i))); //! SEGMENTUAL FAULT

      size_type iLHSC = (i * 2) + 1;
      size_type iRHSC = (i * 2) + 2;

      if (i == 0)
      {
         if (heap[1].priority >= heap[2].priority)
            return 1;
         else
            return 2;
      }

      if (iRHSC < used && heap[iRHSC].priority > heap[iLHSC].priority)
         return iRHSC;
      else
         return iLHSC;
   }

   p_queue::size_type
   p_queue::parent_index(size_type i) const
   // Pre:  (i > 0) && (i < used)
   // Post: The index of "the parent of the item at heap[i]" has
   //       been returned.
   {
      //!      cerr << "parent_index(size_type) not implemented yet" << endl;
      //!      return 0; // dummy return value
      assert(i > 0);
      assert(i < used);

      return ((i - 1) / 2);
   }

   p_queue::size_type
   p_queue::parent_priority(size_type i) const
   // Pre:  (i > 0) && (i < used)
   // Post: The priority of "the parent of the item at heap[i]" has
   //       been returned.
   {
      //!      cerr << "parent_priority(size_type) not implemented yet" << endl;
      //!      return 0; // dummy return value
      assert(i > 0);
      assert(i < used);
      return heap[parent_index(i)].priority;
   }

   p_queue::size_type
   p_queue::big_child_index(size_type i) const
   // Pre:  is_leaf(i) returns false
   // Post: The index of "the bigger child of the item at heap[i]"
   //       has been returned.
   //       (The bigger child is the one whose priority is no smaller
   //       than that of the other child, if there is one.)
   {
      //!      cerr << "big_child_index(size_type) not implemented yet" << endl;
      //!      return 0; // dummy return value
      assert(!(is_leaf(i)));

      size_type i_lhsc = (i * 2) + 1;
      size_type i_rhsc = (i * 2) + 2;

      if (i == 0)
      {
         if (heap[1].priority >= heap[2].priority)
            return 1;
         else
            return 2;
      }

      if (i_rhsc < used && heap[i_rhsc].priority > heap[i_lhsc].priority)
         return i_rhsc;
      else
         return i_lhsc;
   }

   p_queue::size_type
   p_queue::big_child_priority(size_type i) const
   // Pre:  is_leaf(i) returns false
   // Post: The priority of "the bigger child of the item at heap[i]"
   //       has been returned.
   //       (The bigger child is the one whose priority is no smaller
   //       than that of the other child, if there is one.)
   {
      //!      cerr << "big_child_priority(size_type) not implemented yet" << endl;
      //!      return 0; // dummy return value
      assert(!(is_leaf(i)));
      return heap[big_child_index(i)].priority;
   }

   void p_queue::swap_with_parent(size_type i)
   // Pre:  (i > 0) && (i < used)
   // Post: The item at heap[i] has been swapped with its parent.
   {
      //!      cerr << "swap_with_parent(size_type) not implemented yet" << endl;
      assert(i > 0);
      assert(i < used);

      size_type parent_idx = parent_index(i);

      ItemType temp_item = heap[parent_idx];

      heap[parent_idx] = heap[i];

      heap[i] = temp_item;
   }
}
